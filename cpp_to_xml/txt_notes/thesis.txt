
Московский государственный университет имени М.В. Ломоносова
Факультет вычислительной математики и кибернетики
Кафедра суперкомпьютеров и квантовой информатики




МАГИСТЕРСКАЯ ДИССЕРТАЦИЯ

Разработка подхода к анализу информационной структуры программ на языке Си


					

Выполнила: студентка 623 группы
Гадиева Т.Р.
Научный руководитель: к.ф-м.н.
Антонов А.С.

















Москва, 2025
Содержание
Содержание	2
1. Введение	4
2. Постановка задачи	4
3. Обзор применения графового подхода для изучения особенностей программ на языке Си	4
3.1. Синтаксические анализаторы SAX и DOM	4
3.2. Примеры библиотек для обработки XML-файлов в стиле DOM	4
3.3. Компилятор привязки данных	4
3.4. Дополнительные решения для обработки XML-файлов	4
4. Обзор методов анализа зависимостей по данным программ на языке Си	4
4.1. Понятие зависимостей по данным	5
4.2. Статический подход	6
4.3. Динамический подход	8
4.4. Гибридный подход	10
4.5. Сравнение библиотек	11
5. Обзор применения графового подхода для изучения особенностей программ на языке Си	12
5.1. Синтаксические анализаторы SAX и DOM	13
5.2. Примеры библиотек для обработки XML-файлов в стиле DOM	13
5.3. Компилятор привязки данных	13
5.4. Дополнительные решения для обработки XML-файлов	13
6. Обзор средств, применяемых для лексического и синтаксического разбора программ на языке Си	13
6.1. Lex и Yacc	13
6.2. ANTLR4	15
6.3. LLVM и Clang	16
7. Выбор подхода к решению поставленной задачи	19
7.1. А	19
7.2. Б	19
7.3. В	19
7.4. Г	19
7.5. д	19
8. Программная реализация	19
8.1. Схема работы программы	19
8.2. Основные этапы работы программы	19
8.2.1. Конвертация в JSON	19
8.2.2. Сбор входных данных	19
8.2.3. Вычисление математических выражений	19
8.2.4. Основной цикл	19
8.2.5. Формирование выходных данных	19
8.3. Расположение вершин информационного графа	19
8.4. Примеры результатов выполнения программы	19
9. Результаты работы	19
10. Список литературы	19














Введение
Постановка задачи
Обзор применения графового подхода для изучения особенностей программ на языке Си
р
Обзор методов анализа зависимостей по данным программ на языке Си
Введение
В данной работе анализ информационной структуры программы осуществляется посредством построения её информационного графа. По определению[1], такой граф отражает зависимости между операциями программы, основанные на передаче данных от одной операции к другой[2]. Таким образом, он представляет собой один из видов графов, описывающих зависимости по данным. 
В связи с этим для решения поставленной задачи были рассмотрены существующие подходы, направленные на извлечение и интерпретацию зависимостей по данным в программах на языке Си. Актуальность данной задачи обусловлена широким спектром её применений, включая:
оптимизацию программ (в том числе в современных компиляторах, таких как Clang, GCC);
автоматическое распараллеливание кода[3];
трансформации циклов, такие как разбиение на блоки (tiling), объединение (fusion), перестановка (interchange) и разделение (fission) [4];
автоматическую векторизацию[5].
В следующих разделах рассматриваются методы анализа зависимостей, классифицируемые на статические, динамические и гибридные, с акцентом на их применимость к программам на языке Си.
Понятие зависимостей по данным
Зависимостью по данным называют ситуацию, при которой две инструкции программы обращаются к одной и той же области памяти, и хотя бы одна из них выполняет запись [6][7]. Наличие таких зависимостей влияет на допустимый порядок исполнения инструкций, особенно в контексте оптимизаций и параллельного исполнения. Анализ этих зависимостей лежит в основе различных трансформаций кода и построения формальных представлений программ, таких как графы зависимостей.
Выделяют несколько типов зависимостей[8]:
Read-after-Write (RAW) – истинная зависимость: инструкция читает значение, ранее записанное другой инструкцией. Это наиболее распространённый вид зависимостей; его нарушение может привести к некорректным вычислениям.
Write-after-Read (WAR) – антизависимость: инструкция записывает значение в область памяти, которую ранее прочитала другая инструкция. Такие зависимости необходимо учитывать при наличии вероятности записи до завершения чтения.
Write-after-Write (WAW) – повторная запись: несколько инструкций записывают данные в одну и ту же область памяти. Корректность исполнения требует соблюдения порядка записей.
Read-after-Read (RAR) – повторное чтение: обе инструкции читают одну и ту же область памяти. Этот тип зависимости не ограничивает порядок исполнения, поскольку чтение не изменяет состояние памяти.
Среди перечисленных типов зависимостей наибольшее значение в контексте потока данных имеют истинные зависимости, так как они указывают на факт передачи значения от одной операции к другой. Именно этот тип зависимости рассматривается в данной работе при построении информационного графа программы. В таком графе вершины соответствуют операциям, а ребра указывают на то, что результат одной операции используется в качестве входных данных в другой. Таким образом, информационный граф отображает исключительно истинные зависимости (RAW).
При этом информационный граф может включать как зависимости между различными итерациями одного и того же цикла (межитерационные), так и зависимости между отдельными операциями внутри одной итерации или вне циклов (межоперационные), поскольку обе категории отражают зависимости, заданные определением.
(Подобный подход нередко применяется в актуальных инструментах анализа зависимостей. В частности, инструмент динамического профилирования DiscoPoP для определения потенциального параллелизма в последовательных программах использует метод, который основан на концепции вычислительных единиц, следующих шаблону чтение-вычисление-запись[9].)
Статический подход
Статический анализ зависимостей выполняется без запуска программы на основе синтаксической и семантической информации, доступной в исходном коде, включая структуру циклов, выражения индексов массивов и области определения переменных. Его целью является выявление инструкций, ограничивающих возможность безопасной перестановки, векторизации и распараллеливания операций.
Чаще всего статические методы применяется к регулярным фрагментам программ (regular or static control programs) [10]. В них границы циклов и обращения к данным можно выразить в виде аффинных функций, то есть линейных выражений с возможным свободным членом [11], от переменных цикла и параметров [12]. Такой класс программ допускает применение полиэдральной модели (polyhedral model) [13], которая представляет итерационные пространства циклов и зависимости между ними с помощью систем линейных неравенств. В рамках этой модели можно формально анализировать межитерационные зависимости и строить графы зависимостей по данным. 
Одним из наиболее известных инструментов для языка Си, реализующих полиэдральный подход, является PLUTO [14]. Используя аффинные представления индексов и границ итераций, инструмент составляет и анализирует целочисленные системы линейных неравенств с целью получения информации о наличии зависимостей между парами итераций. PLUTO предназначен для достижения параллелизма и улучшения локальности данных путём применения аффинных преобразования для эффективного разбиения на блоки (tiling) и слияния циклов (fusion). 
Аналогичный подход применяется в Polly – инфраструктуре оптимизации на основе полиэдральной модели для компилятора LLVM (поддерживает возможность использования исходного кода на языке Си). Polly анализирует и оптимизирует шаблоны доступа к памяти, используя абстрактное математическое представление на основе целочисленных полиэдров. Данный инструмент выполняет классические трансформации циклов, такие как разбиение на блоки и слияние циклов, для улучшения локальности данных, а также может использовать параллелизм уровня OpenMP и выявлять возможности для SIMD-оптимизаций[15].
Поскольку статические методы анализа зависимостей по данным не требуют запуска программы, это обеспечивает их высокую производительность. Однако, по этой же причине, они сталкиваются с рядом ограничений, особенно при обработке конструкций, поведение которых невозможно точно предсказать без непосредственного выполнения программы. К таким случаям относятся, в частности:
неаффинные зависимости индексов;
использование значений элементов массивов при вычислении границ циклов и условий переходов;
косвенная адресация;
наличие указателей.
В таких ситуациях статический анализ может быть дополнен динамическим, который, несмотря на накладные расходы, способен предоставить более точную информацию о зависимостях в программе во время ее выполнения.
Динамический подход
Динамические подходы к анализу преодолевают ограничения статического метода и позволяют работать с более широким классом задач, включая случаи с указателями, косвенной адресацией и данными, известными только во время выполнения. Однако такие методы сопровождаются значительными накладными расходами. Каждый доступ к памяти требует дополнительной обработки: фиксируются адрес, тип операции, номер итерации, и выполняется проверка наличия зависимостей. В ряде исследований сообщается о замедлении исполнения программ в 10–20 раз по сравнению с исходным кодом без анализа [19][20].
Одним из наиболее известных инструментов, реализующих динамический подход, является Prospector – инструмент динамического анализа, предназначенный для выявления потенциально параллелизуемых циклов. Он применяет динамическую бинарную инструментализацию [17], вставляя в исполняемый код вызовы, фиксирующие каждое обращение к памяти. При каждом чтении или записи регистрируются: адрес памяти, тип операции (чтение/запись), идентификатор инструкции и текущая итерация цикла.
Собранные трассы (traces) – журналы фактического обращения к памяти – используются для построения набора зависимостей между итерациями, включая RAW, WAR и WAW. Каждая зависимость указывается в виде пары итераций, между которыми существует конфликт по данным. Далее Prospector анализирует полученный граф зависимостей, чтобы определить, существует ли возможность распараллеливания – например, сдвига границ итераций (loop skewing) или их независимого исполнения [18].
В отличие от статического анализа, Prospector не ограничен синтаксически корректными аффинными циклами и способен выявлять параллелизм даже в коде с нерегулярными шаблонами доступа, указателями и условными переходами, что и свойственно динамическим подходам.
Другим примером динамического анализа зависимостей является инструмент DiscoPoP[9]. Он также работает по принципу вставки вызовов обработчика на обращения к памяти и составление трасс исполнения, но делает это на другом уровне абстракции – DiscoPoP работает напрямую с исходным кодом. На основе собранных трасс инструмент строит граф истинных (RAW) зависимостей между инструкциями, в котором ребра отражают конфликты по доступу к общей памяти. Выявленные зависимости могут быть как межитерационными, так и межоперационными.
Гибридный подход
Гибридные подходы призваны совмещать сильные стороны статического и динамического анализа, минимизируя их недостатки. В таких системах статический анализ используется для предварительной фильтрации или упрощения задачи: он заранее определяет зависимости, которые возможно точно установить на основе исходного кода и передает информацию дальше. Динамический подход применяется уже только к тем участкам, где поведение программы зависит от входных данных или структур, не поддающихся статическому анализу – таких как указатели, косвенные обращения, ветвления и нерегулярные шаблоны доступа.
В работе [19] гибридный подход рассмотрен как способ ускорения анализа зависимостей по данным динамическим подходом. Статический инструмент PLUTO, упомянутый ранее, анализирует циклы с регулярными структурами доступа[10] и помечает проанализированные участки как “безопасные” (hints), исключая их из последующего профилирования. Оставшиеся участки передаются на анализ инструменту DiscoPoP, который записывает трассы только по нерегулярным фрагментам. Такой подход позволяет покрыть всю программу, но при этом снизить накладные расходы на профилирование
Исследование [20] сосредоточено на анализе зависимостей для разреженных вычислений, где доступ к памяти осуществляется посредством косвенной адресации. Это характерно, например, для распространенного формата хранения данных CSR (Compressed Sparse Row)[]. На статическом этапе используется информация, доступная на момент компиляции, о свойствах индексных массивов — таких как монотонность и уникальность значений — для доказательства отсутствия конфликтов между итерациями. Это позволяет исключить часть зависимостей без выполнения программы. Оставшиеся случаи обрабатываются на этапе динамического анализа с помощью автоматически сгенерированных инспекторов, которые выполняются перед основным вычислением и проверяют наличие конфликтов по данным между парами итераций на основании фактических значений индексных массивов. Такой подход также позволяет существенно снизить объём и время чистого динамического анализа.

Сравнение библиотек
[1]. https://ru.wikipedia.org/wiki/%D0%93%D1%80%D0%B0%D1%84_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B0
[2]. Новиков А. С. Построение графа информационных зависимостей по машинному коду. // Известия ТулГУ. 2016.
[3]. Norouzi et al., “Fast data-dependence profiling through prior static analysis” (Parallel Computing, 2024)
[4]. Sampaio et al., “Hybrid Data Dependence Analysis for Loop Transformations”, INRIA (2015)
[5]. PLUTO project, polyhedral loop transformations. https://pluto-compiler.github.io
[6]. https://en.wikipedia.org/wiki/Data_dependency
[7] Bernstein, A. J. (1966). Analysis of Programs for Parallel Processing. IEEE Transactions on Electronic Computers, EC-15(5), 757–763. doi:10.1109/PGEC.1966.264565.
[8]. https://en.wikipedia.org/wiki/Dependence_analysis
[9]. https://apps.fz-juelich.de/jsc-pubsystem/aigaion/attachments/IPTW2014_DiscoPoP.pdf-75e21f443ec3ca6bd3d45fb5170c8b63.pdf
[10]. https://dl.acm.org/doi/10.1145/2838734 (полиэдральная модель)
[11] https://www.cs.colostate.edu/~cs560/Spring2012/ClassNotes/lecture09-poly-dependence.ppt.pdf
[12]. https://www.cs.cornell.edu/courses/cs6120/2023fa/blog/polyhedral/
[13]. Polyhedron Model из Encyclopedia of Parallel Computing (https://link.springer.com/referenceworkentry/10.1007/978-0-387-09766-4_502)
[14]. pluto-compiler.sourceforge.net
[15]. https://polly.llvm.org/
[16]. ??
[17]. https://habr.com/ru/articles/666274/
[18]. https://faculty.cc.gatech.edu/~hyesoon/prospector_4page.pdf?utm_source=chatgpt.com
[19] Norouzi, M., Luk, C.-K., & Kim, H. (2024). Fast data-dependence profiling through prior static analysis. Parallel Computing, 103063. https://doi.org/10.1016/j.parco.2024.103063ACM Digital Library
[20] Mohammadi, M. S., Yuki, T., Cheshmi, K., Davis, E. C., Hall, M., Mehri Dehnavi, M., Nandy, P., Olschanowsky, C., Venkat, A., & Strout, M. M. (2019). Sparse computation data dependence simplification for efficient compiler-generated inspectors. In Proceedings of the 40th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI '19) (pp. 594–609). ACM. https://doi.org/10.1145/3314221.3314646pldi19.sigplan.org+7dblp.org+7www2.cs.arizona.edu+7
Обзор применения графового подхода для изучения особенностей программ на языке Си
Графовые модели широко применяются в анализе программ,  поскольку позволяют визуализировать структуру кода и облегчают изучение зависимостей его элементов и потока управления. 
Графовые представления применяются как в статическом, так и в динамическом анализе программ на языке Си. В динамическом анализе графы зависимостей формируются на основе фактического поведения программы при ее исполнении. Это могут быть графы вызовов (Dynamic Call Graph, DCG) [1], графы исполнения (Execution Trace Graph, ETG) [2] и динамические графы зависимостей по данным (Dynamic Data Dependence Graph, DDDG) [3], фиксирующие только те связи, которые формируются при выполнении кода с конкретными входными данными. 
Однако в данной работе основной интерес представляет статический анализ, позволяющий извлекать информационную структуру программы без ее запуска. В связи с этим далее рассматриваются графовые модели, применяемые в научной области в рамках статического анализа программ на Си.
AST
Абстрактное синтаксическое дерево (AST, Abstract Syntax Tree) – это ориентированный ациклический граф в котором узлы соответствуют синтаксическим конструкциям исходного кода, а ребра – иерархическим отношениям между ними (см. Рис.) [4]. В отличие от полного синтаксического дерева (Concrete Syntax Tree, CST или parse tree) [5], AST опускает детали синтаксического оформления, например, скобки и запятые, и содержит только логически значимые компоненты программы: операторы, выражения, блоки, условия, объявления и т.д. [6]


Рис. Абстрактное синтаксическое дерево для представленного фрагмента кода алгоритма Евклида
AST является одним из фундаментальных концептов в компьютерных науках и широко используется как базовое представление в компиляторах и системах статического анализа. Оно обеспечивает основу семантического анализа: позволяет проверять типы данных, корректность операций и контекста. Используется при оптимизации кода, как на уровне преобразования исходного кода, так и на уровне промежуточных представлений IR. На основе AST также строятся и другие вспомогательные графы, такие как графы потока управления (Control Flow Graph, CFG), отражающие передачу управления между инструкциями в программах, и графы потока данных (Data Flow Graph, DFG), описывающие причинно-следственные зависимости между вычислениями и переменными.
Граф потока управления (CFG)
Граф потока управления (CFG) – это ориентированный граф, в котором узлы представляют базовые блоки (последовательности инструкций без ветвлений), а ребра – возможные переходы управления между ними. Он описывает все потенциальные пути исполнения программы, определяемые условными операторами, такими как if, while, for, switch и др. (см. Рис. ) [8]

Рис. Граф потока управления для подпрограммы на языке Си++
CFG активно применяется в задачах анализа достижимости, устранения мертвого кода, выделения независимых участков кода и обнаружения уязвимостей.  Например, в работе “Static Detection of Control-Flow-Related Vulnerabilities Using Graph Embedding” [9] граф потока управления строится на основе исходного кода программ на C/C++ и используется для обучения графовой сверточной сети (GCN). Нейронная сеть обучается распознавать шаблоны уязвимостей и служит для классификации фрагментов кода на уязвимые и безопасные.
Граф потока данных (DFG) и другие графы зависимостей по данным
В графе потока данных (Data Flow Graph, DFG) узлы представляют операции (функции), применяемые к объектам данных, а ребра – передачу данных от операции, формирующей их, к операции, использующей их (см.Рис.) [11].

Рис. Граф потока данных для подпрограммы на языке Си
Помимо DFG существует и другие виды графов зависимостей по данным, например:
Граф зависимостей по данным (Data Dependency Graph, DDG) – это ориентированный граф, в котором узлы представляют инструкции программы, а ребра – зависимости по данным между этими инструкциями (RAW, WAW, WAR).
Граф истинных зависимостей (True Dependence Graph) – это ориентированный ациклический граф, в котором узлы соответствуют инструкциям программы, а ребра отражают только истинные зависимости.
Граф зависимостей инструкций (Instruction Dependence Graph, IDG) – это ориентированный граф, в котором узлы представляют инструкции программы, а ребра – все зависимости, влияющие на корректный порядок их исполнения, такие как зависимости по данным и управляющие зависимости (зависимости от ветвлений на основе условий).
Таким образом, несмотря на наличие большого множества различных графов, отвечающих за зависимости по данным в программах, в зависимости от рассматриваемой задачи возникает потребность в использовании конкретного вида графа, отражающих определенные характеристики этих зависимостей. Например, в исследовательской работе «Graph based Data Dependence Identifier for Parallelization of Programs» используется концепция графа зависимостей по данным (DDG) с альтернативным подходом к его построению с целью реализации автоматической параллелизации программ [12].
Информационный граф алгоритма
В данной работе мы сосредоточены на изучении информационной структуры программ на языке Си посредством формирования их информационного графа, который также является одним из разновидностей графов, отражающих зависимости по данным. Информационный граф — это ациклический ориентированный граф, вершины которого соответствуют операциям алгоритма, а дуги — связям по данным между этими операциями. Две вершины связываются дугой, если вторая использует данные, вычисленные в первой.
Его ацикличность следует из того, что в любых программах реализуются только явные вычисления и никакая величина не может определяться через саму себя, в том числе и рекурсия реализует однотипные, но разные операции.
Анализ информационных графов алгоритмов играет важную роль в исследовании внутреннего параллелизма алгоритмов. Под внутренним параллелизмом подразумевается заложенный в их последовательной реализации потенциал к распараллеливанию. Также он даёт возможность определить множества независимых друг от друга операций, найти подходящее распределение операций по процессорам вычислительной системы, обнаружить узкие места и т.д. []
Специализированные и Комбинированные графы

Источники
[2]. https://ieeexplore.ieee.org/document/8249855
[4]. https://en.wikipedia.org/wiki/Abstract_syntax_tree
[5]. https://en.wikipedia.org/wiki/Parse_tree
[6]. https://www.geeksforgeeks.org/abstract-syntax-tree-vs-parse-tree/
[7]. Zhou Y., Liu S., Siow J., Du X., Liu Y.
Devign: Effective Vulnerability Identification by Learning Comprehensive Program Semantics via Graph Neural Networks [Электронный ресурс] // arXiv preprint arXiv:1909.08667. – 2019. – Режим доступа: https://arxiv.org/pdf/1909.03496#:~:text=%E2%80%A2%20In%20the%20composite%20code,as%20 possible%2C%20and%20enables%20to
[8] https://blog.jetbrains.com/clion/2023/11/striving-for-better-cpp-code-part-i-data-flow-analysis-basics/
[9] https://jumormt.github.io/data/iceccs19.pdf#:~:text=graph%20embedding%20to%20perform%20classic,the%20form%20of%20adjacency%20matrix
[10]https://link.springer.com/referenceworkentry/10.1007/978-0-387-09766-4_294
[11] https://www.researchgate.net/publication/224517165_Solver_technology_for_system-level_to_RTL_equivalence_checking
[12]https://arxiv.org/pdf/2102.09317
[13]
Обзор средств, применяемых для лексического и синтаксического разбора программ на языке Си
Для решения поставленной в данной работе задачи по анализу информационной структуры программ на языке Си необходимо формальное представление структуры исходного кода. Для этого необходимо наличие этапа синтаксического и лексического анализа, в ходе которого текст программы преобразуется во внутреннюю программную структуру, чаще всего AST дерево [1]. В связи с этим в работе рассматриваются существующие инструменты автоматической генерации анализаторов, широко применяемые в научной области. 
Lex и Yacc
Lex и Yacc – классические инструменты генерации лексических и синтаксических анализаторов, которые, соответственно, часто применяются для создания парсеров [2][3]. На их основе написаны различные расширенные реализации, такие как Flex и Bison, расширенная и свободно распространяемая реализация, или  PLY (Python Lex-Yacc) – библиотека для языка Python, предоставляющая аналогичный функционал.
Lex и Yacc в своей работе используют подход на основе формальных грамматик. Yacc работает с грамматиками класса LALR(1) [4], то есть анализатор принимает решения, глядя только на один токен вперёд. Эта особенность подразумевает, что нужно уделять особое внимание описанию приоритетов и ассоциативности операторов, особенно при построении выражений[5]. Для таких случаев обычно используется левая рекурсия, которая поддерживается и предпочтительна в LALR-анализе. Но несмотря на некоторые сложности с использованием этого типа грамматики, Yacc и Lex способны эффективно обрабатывать большинство конструкций языков программирования, включая Си [6].
Особенность Yacc заключается в том, что семантические действия пишутся напрямую внутри правил грамматики на языке C. Это позволяет управлять построением абстрактного синтаксического дерева (AST), таблиц переменных и других структур уже на этапе синтаксического анализа. Однако такой подход предполагает, что вся логика обработки синтаксических конструкций реализуется вручную: разработчик сам отвечает за создание узлов дерева, ведение областей видимости и регистрацию идентификаторов в таблице символов. Таким образом, Yacc предоставляет полный контроль над процессом анализа, но требует более низкоуровневой и детальной реализации по сравнению с современными инструментами, где эти действия выполняют отдельные встроенные обработчики.
Второй инструмент – Lex используется для лексического анализа. Он распознаёт токены по регулярным выражениям и связывает каждое совпадение с пользовательским действием, что позволяет осуществлять предобработку текста еще до синтаксического разбора. В связке с Yacc он обеспечивает полный цикл обработки текста программы.
ANTLR4
Одним из широко распространенных и используемых инструментов является ANTLR (Another Tool for Language Recognition). Это генератор парсеров, ориентированный на разбор, трансформацию и интерпретацию структурированных текстов, поддерживающий множество целевых языков программирования, включая C++, Java, Python и другие [7]. Наиболее актуальной версией является ANTLR4, которая принципиально отличается от предыдущих поколений своим подходом к построению древовидной структуры на основе входных данных и поддержкой гибких инструментов обхода.
ANTLR4 работает на основе LL(*) грамматики [8], что представляет собой глубоко адаптивный анализ с произвольным числом токенов вперёд.  Описание такой грамматики требует устранения левой рекурсии, но делает ее более читаемой.
В качестве входных данных ANTLR4 запрашивает пользовательское описание синтаксиса целевого языка, записанного в файл грамматики (*.g4). На его основе инструмент автоматически генерирует набор классов парсера. После генерации пользователю предоставляются деревья разбора (parse trees), которые можно обходить и обрабатывать с помощью встроенных механизмов слушателей (listener) и посетителей (visitor). Эти механизмы позволяют реализовывать произвольную пользовательскую логику: построение абстрактных синтаксических деревьев (AST), семантический анализ, генерацию кода, интерпретацию и трансформацию программ [9]. 
Таким образом, подход к разбору исходных данных, предоставляемый ANTLR4, является более гибким по сравнению с Yacc/Lex, напрямую составляющими AST деревья. Также ANTLR4 избавляет разработчика от необходимости прописания ручных правил для парсера за счёт полностью автоматической генерации только на основе составленного файла грамматики.
Практическая значимость ANTLR также подтверждается его использованием в научных и учебных проектах. В исследовании [10] ANTLR сравнивается с Yacc/Lex, и показано, что он обеспечивает более читаемые и расширяемые грамматики, а также упрощает реализацию семантической обработки.
LLVM и Clang
LLVM или Low Level Virtual Machine — это компиляторная инфраструктура, которая изначально была создана для поддержки многоступенчатой системы оптимизаций промежуточного представления кода. Архитектура LLVM cоcтоит из следующих компонентов[11]:
LLVM IR – платформонезависимое промежуточное представление
Фронтенд – компонент, преобразующий код на исходном языке программирования в промежуточное представление. Наиболее известным примером является Clang, который обрабатывает языки C, C++ и Objective-C.
Оптимизатор – производит оптимизации на уровне промежуточного представления.
Бэкенд – преобразует LLVM IR в целевой машинный код или другой заданный формат.
Разбор программы на языке C с использованием LLVM включает несколько этапов. Сначала Clang выполняет предварительную обработку, лексический и синтаксический анализ, в результате чего строится синтаксическое дерево (AST). Доступ к нему предоставляется через API библиотеки LibTooling, включая такие механизмы, как RecursiveASTVisitor и AST Matchers, которые позволяют проходить и анализировать дерево в программном виде. Это позволяет выделять конкретные конструкции, например, операторы, объявления, блоки, фильтровать их по условиям и использовать в дальнейших фазах анализа. Такой подход, в частности, был применён в научной работе по генерации мутаций в программах на языке Си (название) в целях тестирования устойчивости тестов к изменению кода [12].
Хотя Clang является частью инфраструктуры LLVM, в задачах синтаксического разбора он используется независимо от остальных компонентов: все операции выполняются на уровне AST, без необходимости генерации промежуточного представления LLVM IR. Последнее может потребоваться лишь при дальнейших этапах трансляции или оптимизации, выходящих за рамки синтаксического анализа. Например, представление LLVM IR использовалось в проекте Checked C, где после разбора исходного кода Clang вставлял проверки безопасности указателей, а их реализация происходила уже на уровне IR [13].
Важное отличие такого подхода от Yacc/Lex и ANTLR4 заключается в том, что Clang не предоставляет механизмов для задания пользовательской грамматики. Полный набор грамматических конструкций языка Си встроен в структуру парсера. Поэтому настроить ограниченное подмножество языка можно только после разбора – на этапе анализа построенного дерева – путем фильтрации нежелательных конструкций или с помощью сторонних инструментов анализа.

Литература
[1]. https://en.wikipedia.org/wiki/Abstract_syntax_tree
[2]. Ortin F., Quiroga J., Rodriguez-Prieto O., Garcia M. (2022)
В статье "An empirical evaluation of Lex/Yacc and ANTLR parser generation tools"
[3]. Vignesh K., Hanumat M., Reddy N., Mohith S., Belwal M. (2024)
В работе "ToY Language Compiler using Lex and YACC"
[4]. https://ru.wikipedia.org/wiki/LALR(1)
[5]. https://silcnitc.github.io/yacc.html
[6]. "Compilers: Principles, Techniques, and Tools" (также известна как "Драконья книга") авторов Альфреда Ахо, Моники Лам, Рави Сети и Джеффри Ульмана. Глава 4
[7]. The ANTLR Mega Tutorial. [Электронный ресурс]. — Электрон. дан. — URL: https://tomassetti.me/antlr-mega-tutorial/
[8]. https://theantlrguy.atlassian.net/wiki/spaces/~admin/pages/524294/LL+grammar+analysis
[9]. https://github.com/antlr/antlr4
[10]. Ortin F., Quiroga J., Rodriguez-Prieto O., Garcia M. An empirical evaluation of Lex/Yacc and ANTLR parser generation tools // PLOS ONE. 2022. Vol. 17, No. 3. P. e0264326. DOI: 10.1371/journal.pone.0264326
[11]https://llvm.org/
[12]SRCIROR: A Toolset for Mutation Testing of C Source Code and LLVM Intermediate Representation – Farah Hariri, August Shi, 2018. 
[13] Checked C: Making C Safe by Extension – Archibald Samuel Elliott et al., 2018.
Выбор подхода к решению поставленной задачи
Рассмотренные подходы к решению задачи
Описание построенной реализации
Программная реализация
Ограничение построенной реализации
Ограничение подмножества Си
Генерация лексического и синтаксического анализатора
Обработка математических выражений
Сбор информации о зависимостях
Хранение информации о зависимостях
Приведение к языку Algolang
Примеры работы программы
Результаты работы
Список литературы


